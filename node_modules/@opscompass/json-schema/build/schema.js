"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = void 0;
var _2019_1 = require("ajv/dist/2019");
var draft7MetaSchema = require("ajv/dist/refs/json-schema-draft-07.json");
/* eslint @typescript-eslint/no-var-requires: "off" */
function findProperty(jsonObject, validKeys) {
    var value;
    var returnVal = false;
    Object.keys(jsonObject).forEach(function (k) {
        if (validKeys.includes(k)) {
            returnVal = true;
            return;
        }
        else if (jsonObject[k] && typeof jsonObject[k] === "object") {
            value = findProperty(jsonObject[k], validKeys);
            returnVal = findProperty(jsonObject[k], validKeys);
            return;
        }
    });
    return returnVal;
}
var Schema = /** @class */ (function () {
    function Schema(schema) {
        var ajv = new _2019_1.default({ allErrors: true, strict: false, $data: true });
        require("ajv-keywords")(ajv);
        require("ajv-errors")(ajv);
        require("ajv-formats")(ajv);
        ajv.addMetaSchema(draft7MetaSchema);
        ajv.addKeyword({
            keyword: "withinDays",
            $data: true,
            validate: function (schema, data) {
                var inputDate = new Date(data);
                var today = new Date();
                var timeDiffBackward = Math.floor((today.getTime() - inputDate.getTime()) / (1000 * 60 * 60 * 24));
                var timeDiffForward = Math.floor((inputDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                if (data == null || timeDiffBackward > schema || timeDiffForward > schema) {
                    return false;
                }
                else {
                    return true;
                }
            },
        });
        ajv.addKeyword({
            keyword: "containsNestedElement",
            $data: true,
            validate: function (schema, data) {
                var validValues = schema["enum"];
                var returnVal = findProperty(data, validValues);
                return returnVal;
            },
        });
        ajv.addKeyword({
            keyword: "includesPort",
            $data: true,
            validate: function (schema, data) {
                var invalidPort = parseInt(schema);
                var portRange = data.split("-");
                if (portRange.length === 1) {
                    return parseInt(portRange[0]) === invalidPort;
                }
                var startPort = parseInt(portRange[0]);
                var endPort = parseInt(portRange[1]);
                return startPort <= invalidPort && endPort >= invalidPort;
            },
        });
        ajv.addKeyword({
            keyword: "withinFiveSeconds",
            $data: true,
            validate: function (schema, data) {
                var inputTime = new Date(schema);
                var secondInputTime = new Date(data);
                var timeDiff = Math.abs(inputTime.getTime() - secondInputTime.getTime()) / 1000;
                if (data == null || timeDiff > 5) {
                    return false;
                }
                else {
                    return true;
                }
            },
        });
        ajv.addKeyword({
            keyword: "withinTime",
            $data: true,
            validate: function (schema, data) {
                var time = +data.slice(0, -1);
                var endChar = data.substr(data.length - 1);
                var timeDays;
                if (endChar === "s") {
                    timeDays = time / (60 * 60 * 24);
                }
                else if (endChar === "m") {
                    timeDays = time / (60 * 24);
                }
                else if (endChar === "h") {
                    timeDays = time / 60;
                }
                else {
                    timeDays = time;
                }
                if (data == null || schema <= timeDays) {
                    return false;
                }
                else {
                    return true;
                }
            },
        });
        ajv.addKeyword({
            keyword: "areDutiesSeparated",
            $data: true,
            validate: function (schema, data) {
                var checkAgainstRoles = data.filter(function (r) { return schema.checkAgainst.includes(r.role); });
                var masterRoles = data.filter(function (r) { return schema.master === r.role; });
                var overlap = checkAgainstRoles.some(function (role) {
                    var users = role.members.filter(function (member) { return member.startsWith("user:"); });
                    return masterRoles.some(function (or) {
                        return users.some(function (u) {
                            return or.members.includes(u);
                        });
                    });
                });
                return !overlap;
            },
        });
        ajv.addKeyword({
            keyword: "enumIgnoreCase",
            $data: true,
            validate: function (schema, data) {
                if (typeof data === "string") {
                    var providedValue_1 = data.toLowerCase();
                    return schema.some(function (v) { return typeof v === "string" && v.toLowerCase() === providedValue_1; });
                }
                return schema.some(function (v) { return v === data; });
            },
        });
        ajv.addKeyword({
            keyword: "constIgnoreCase",
            $data: true,
            validate: function (schema, data) {
                if (typeof data === "string") {
                    return data.toLowerCase() === schema.toLowerCase();
                }
                return data === schema;
            },
        });
        this.schema = ajv.compile(schema);
    }
    Schema.prototype.matches = function (resource) {
        var result = this.schema(resource);
        return result;
    };
    Schema.prototype.verify = function (resource) {
        var result = this.schema(resource);
        return {
            errors: this.schema.errors,
            valid: result,
        };
    };
    return Schema;
}());
exports.Schema = Schema;
//# sourceMappingURL=schema.js.map